在Go语言中，文件使用指向os.File类型的指针来表示的，也叫做文件句柄。我们在前面章节使用到过的标准输入
和标准输出os.Stdin os.Stdout,它们的类型都是*os.File 。

```go
package main
import (
    "bufio"
    "fmt"
    "io"
    "os"
)

func main() {
	// 文件句柄，打开文件的描述符
    inputFile, inputError := os.Open("input.dat")
    if inputError != nil {
        fmt.Printf("An error occurred on opening the inputfile\n" +
            "Does the file exist?\n" +
            "Have you got acces to it?\n")
        return // exit the function on error
    }
    defer inputFile.Close()
	
	// 通过使用bufio包提供的读取器，可以很方便的操作string对象，避免了去操作比较底层的字节
    inputReader := bufio.NewReader(inputFile)
    for {
        inputString, readerError := inputReader.ReadString('\n')
        fmt.Printf("The input was: %s", inputString)
        if readerError == io.EOF {
            return
        }      
    }
}
```

将整个文件的内容读取到字符串中，使用ioutil.ReadFil()方法，返回类型是[]byte
```go
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	inputFile := "chapter_12/product.txt"
	outputFile := "chapter_12/product_copy.txt"

	buf, err2 := ioutil.ReadFile(inputFile)
	if err2 != nil {
		fmt.Println(err2)
		return
	}
	fmt.Printf("%s\n", string(buf))

	err3 := ioutil.WriteFile(outputFile, buf, 0644)
	if err3 != nil {
		fmt.Println(err3)
		return
	}
}

```

## 写文件

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	outputFile, err2 := os.OpenFile("output.dat", os.O_WRONLY|os.O_CREATE, 0666)
	if err2 != nil {
		fmt.Println(err2)
		return
	}
	defer outputFile.Close()
    
	// 创建一个写入器（缓冲区）对象
	outputWriter := bufio.NewWriter(outputFile)
	for i := 0; i <= 10; i++ {
		outputWriter.WriteString("hello world!\n")
	}
	outputWriter.Flush()
}

```

OpenFile函数有三个参数：文件名、一个或多个标志、使用的文件权限。

os.O_RDONLY：只读
os.O_WRONLY：只写
os.O_CREATE：创建：如果指定文件不存在，就创建该文件。
os.O_TRUNC：截断：如果指定文件已存在，就将该文件的长度截为 0。

在读文件的时候，文件的权限是被忽略的，所以在使用OpenFile时传入的第三个参数为0。而在写文件时，
不管是windows还是unix,都是0666

