## 概念

协程是独立执行的，它们之间没有通信。它们必须通信才变得更有用：彼此之间发送和接收信息并且协调/同步它们的工作。协程可以使用共享变量来通信，
但是不提倡这样做，因为这种方式给所有的共享内存的多线程都带来了困难。

go有一种特殊的类型，通道（channel），可以发送类型化数据的管道，由其负责协程之间的通信，保证数据的同步性。在任何给定的
时间内，一个数据被设计为只有一个协程可以对其访问，数据的读写能力也可以被传递。

例子。生产者协程在传送带上放置物品，消费者协程拿到物品并打包。

通常使用这样的格式来声明通道：`var identifier chan datatype`

未初始化的通道是nil, 通道只能传输一种类型的数据，所有的类型都适用于通道，空接口也可以，也可以创建通道的通道。

通道实际上是类型化消息的队列，使数据得以传输，它是先进先出的结构可以保证发送给它们的元素的顺序。通道也是引用类型，所以
我们使用make()函数来给它分配内存。这里先声明一个字符串通道ch1，然后创建了它

```go
var ch1 chan string
ch1 = make(chan string)
```

当然可以更短，ch1:=make(chan string)

构建一个int通道的通道： ch2:=make(chan chan int)

函数通道： ch3:=maker(chan func())

通道是第一类对象，可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送它们自身。

## 通信操作符 <-

流向通道（发送）
ch<-int1: 用通道ch发送变量int1

从通道中流出（接收），三种方式
int2<-ch: 变量int2从ch获取新值

int2:= <- ch: 如果int2没有被声明过

<-ch：可以单独调用并获取通道的下一个值，当前值会被丢弃，但是可以用到验证。
```go
if <-ch!=1000{
	...
}
```

为了可读性，通道的命名通常以ch开头或包含chan。

```go
package main

import (
	"fmt"
	"time"
)

func sendData(ch chan string) {
	ch <- "hello"
	ch <- "hello2"
	ch <- "hello3"
}

func getData(ch chan string) {
	var input string
	fmt.Println("end")
	for {
		input = <-ch
		fmt.Println(input)
	}

}

func main() {
	ch := make(chan string)

	go sendData(ch)
	go getData(ch)

	time.Sleep(2e9)
}

```


## 通道阻塞

默认情况下，通信是同步且无缓冲的：在有接受者接收数据之前，发送不会结束。可以想象一个无缓冲的通道在没有空间来保存数据的时候：
必须有一个接受者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。所以通道的发送/接收者在双方准备好之前都是阻塞的。

## 使用带缓冲的通道

一个无缓冲的通道只能包含一个元素，我们给通道提供来一个缓存，可以在make命令中设置它的容量。
```go
ch1 := make(chan string, 100)
```

在缓冲满载（缓冲被全部使用）之前，给一个通道发送数据是不会被阻塞的，而从通道中读取数据也不会被阻塞，直到缓冲空了。

如果容量大于0，通道就是异步的：缓冲满载或者变空之前通信不会阻塞，元素会按照发送的顺序被接收。

## 信号量模式


