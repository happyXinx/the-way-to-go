作为一门21世纪的语言，go原生支持应用之间的通信（网络、客户端和服务端、分布式计算）和程序的并发，程序
可以在不同的处理器和计算机上同时执行不同的代码段。go语言为构建并发程序的代码块是协程和通道。

## 什么是协程 

一个应用程序是运行在机器上的一个进程；进程是一个运行在自己内存空间的独立执行体。一个进程
由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间的一起工作的执行体。

一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但是只有同一个程序在某个时间点
运行在多核或者多处理器上才是真正的并行。

不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险。

在go中应用程序的并发处理被称作`goroutines协程`, 它可以进行更有效的并发运算。在协程和
操作系统线程之间并无一对一的关系，协程是根据一个或多个线程的可用性，映射在他们之上的。协程调读器
在go运行时很好的完成了这个工作。

go使用`channels`来同步协程

当系统调用（比如等待IO）阻塞线程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程
创建和管理方面的复杂工作。

存在两种并发方式，确定性的和非确定性的。go的协程和通道理所应当的支持确定性的并发方式。

协程是根据go关键字调用一个函数或者方法来实现的，这样会在当前的计算过程中开始一个同时进行的函数，在
相同的地址空间中分配了独立的栈，比如go sum()，在后台计算总和。

协程的栈会根据需要进行伸缩，不会出现栈溢出。

在一个协程中，比如它需要非常密集的运算，你可以在循环周期内使用`runtime.Gosched()`，这会让出处理器，
允许运行其他协程；它并不会使当前协程挂起，所以它会自动恢复执行。


## 使用GOMAXPROCS 

当`GOMAXPROCS`大于1时，会有一个线程池管理众多线程。gccgo编译器会使`GOMAXPROCS`与运行中的协程数量相等。

`GOMAXPROCS`等同于并发的线程数量，在一台核心数多余一个的机器上，会尽可能有等同于核心数的线程在并行运行。


## 示例

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("in main()")
	go longWait()
	go shortWait()
	fmt.Println("About to sleep in main()")
	// sleep works with a Duration in nanoseconds (ns) !
	time.Sleep(10 * 1e9)
	fmt.Println("At the end of main()")
}

func longWait() {
	fmt.Println("Beginning longWait()")
	time.Sleep(5 * 1e9) // sleep for 5 seconds
	fmt.Println("End of longWait()")
}

func shortWait() {
	fmt.Println("Beginning shortWait()")
	time.Sleep(2 * 1e9) // sleep for 2 seconds
	fmt.Println("End of shortWait()")
}
```

当main函数返回时，程序退出，它不会等待任何其他非main协程的结束。这就是为什么在服务器处理
程序中，每一个请求都会启动一个协程来处理，serve()函数必须保持运行状态，通常使用一个无限循环
来达到目的。

另外，协程是独立的处理单元，一旦陆续启动一些协程，你无法确定它们是什么时候开始执行的，你必须独立于
协程调用的顺序。





