通道可以被显式的关闭; 尽管它们和文件不同，不必每次都关闭。
只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道。
只有发送者需要关闭通道，接收者永远不会需要。


我们如何在通道的`sendData()`完成的时候发送一个信号，`getData()`又如何
检测到通道是否关闭或阻塞？

第一个可以通过函数`close(ch)`来完成，给已经关闭的通道发送或者再次关闭都会
导致运行时panic。

```go
ch := make(chan float64)
defer close(ch)
```

如何来检测通道没有被阻塞（或者没有被关闭）：

```go
v, ok := <-ch
```

通常和if语句一起使用：

```go
if v, ok := <-ch; ok {
  process(v)
}
```

或者在for循环中接收的时候，当关闭或者阻塞的时候使用break:

```go
v, ok := <-ch
if !ok {
  break
}
process(v)
```

