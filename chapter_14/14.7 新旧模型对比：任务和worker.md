一个worker处理一项任务。任务可以被定义为一个结构体
```go
type Task struct {
	// some state
}
```

旧模式： 使用共享内存进行同步

由各个任务组成的任务池共享内存，为了同步各个worker以及避免资源竞争，我们
需要对任务池进行加锁保护：

```go
type Pool struct {
	Mu sync.Mutex
	Tasks []Task
}
```

`sync.Mutex`(互斥锁： 它用来在代码中保护临界区的资源： 同一时间只有1个协程可以进入该临界区) 

```go
func Worker(pool *Pool) {
	for {
	    pool.Mu.lock()
		task := pool.Task[0]
		pool.Tasks = pool.Task[1:]
		pool.Mu.Unlock()
		process(task)
    }
}
```

加锁实现同步在工作协程比较少时可以工作的很好，但是当工作协程数量很大，任务量也很多时，
处理效率将会因为频繁的加锁/解锁开销而降低。


**新模式： 使用通道**

使用通道进行同步： 使用一个通道接受需要处理的任务，一个通道接受处理完成的任务。worker在协程中启动，
其数量N应该根据任务数量进行调整。

```go
func main() {
    pending, done := make(chan *Task), make(chan *Task)
	go sendWork(pending)
	for i:=0; i<N; i++ {
	    go Worker(pending, done)	
    }
	consumeWork(done)
}
```






















