## Go的动态类型

在经典的面向对象语言中数据和方法被封装为类的概念：类包含它们两者，
并且不能剥离。

Go没有类：数据（结构体或更一般的类型）和方法是正交关系。

接收一个或多个接口类型作为参数的函数，其实参可以是任何实现了该接口的类型。

## 动态方法调用

像Python, Ruby这类语言，动态类型是延迟绑定的： 方法只是用参数和变量简单地调用，然后在
运行时才解析。

Go的实现与此相反，通常需要编译器静态检查的支持：当变量被赋值给一个接口类型的变量时，编译器会
检查其是否实现了该接口的所有函数。

## 接口的提取

`提取接口`是非常有用的设计模式，可以减少需要的类型和方法数量，而且不需要像传统的
基于类的面向对象语言那样维护整个的类层次结构。

## 空接口和函数重载 

在Go语言中函数重载可以用可变参数`...T`作为函数最后一个参数来实现。这样就允许我们传递任何数量
任何类型的参数给函数，即重载的实际含义。

```go
fmt.Printf(format string, a ...interface{}) (n int, errno error)
```

## 接口的继承 

当一个类型包含（内嵌）另一个类型的指针时，这个类型就可以使用（另一个类型）所有的接口方法。

```go
type Task struct {
	Command string
	*log.Logger
}

func NewTask(command string, logger *log.Logger) *Task {
    return &Task{command, logger}
}

task.Log()
```

类型可以通过继承多个接口来提供像`多重继承`一样的特性：
```go
type ReaderWriter struct {
    *io.Reader
    *io.Writer
}
```

