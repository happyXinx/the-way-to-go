## go的动态类型

在经典的面向对象语言中数据和方法被封装为类的概念：类包含他们两者，并且不能剥离。

go没有类：数据和方法是一种松耦合的关系。

和其他语言相比，go是唯一结合了接口值，静态类型检查（是否该类型实现了某个接口），运行时动态转换的语言，并且
不需要显式地声明类型是否满足某个接口。该特性允许我们在不改变已有代码的情况下定义和使用新接口。

接收一个（或多个）接口类型做为参数的函数，其实参可以是任何实现该接口的类型的变量。

## 动态方法调用

当变量被赋值给一个接口类型的变量时，编译器会检查其是否实现了该接口的所有函数。如果方法作用于interface{}泛型上，可以通过类型断言来检查
是否实现了该接口。

```go
type xmlWriter interface {
	WriteXML(w io.Writer) error
}
```
现在我们可以实现适用于该流类型的任何变量的StreamXm()函数，并用类型断言检查传入的变量是否实现了该接口；如果没有，
我们就调用内建的`encodeToXm()`来完成相应的工作。

## 接口的提取

提取接口是非常有用的设计模式，整个设计可以持续性的演进，而不用废弃之前的决定。类型要
实现某个接口，它本身不用改变，你只要在这个类型上实现新的方法。

## 空接口和函数重载

在go语言中函数重载可以用可变参数...做为函数的最后一个参数来实现。如果我们把T换为空接口，那么可以知道任何类型的变量都是满足T（空接口）
类型的，这样就允许我们任何数量任何类型的参数给函数，即重载的实际含义。

## 接口的继承

当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用另一个类型的所有接口方法。

例如:
```go
type Task struct {
	Command string
	*log.Logger
}

func NewTask(command string, logger *logger.Logger)  {
    return &Task{command, logger}
}

// logger实现了log方法时，Task的实例task就能调用
task.Log()

```




