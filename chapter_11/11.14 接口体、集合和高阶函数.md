通常你在应用中定义了一个结构体，那么你也可能需要这个结构体的对象集合，比如：

```go
type Any interface{}
type Car struct {
	Model        string
	Manufacturer string
	BuildYear    int
	// ...
}

type Cars []*Car
```
在定义所需功能时我们可以利用函数作为（其他函数的）参数的事实来使用高阶函数，例如：

1） 定义一个通用的`Process()`函数，它接收一个作用于每一辆car的函数f作参数：

```go
// Process all cars with the given function f:
func (cs Cars) Process(f func(car *Car)) {
    for _, c := range cs {
        f(c)
    }
}
```

2）在上面的基础上，实现一个查找函数来获取子集合，并在Proces()中传入一个闭包执行（这样可以访问局部切片）：

```go
func (cs Cars) FindAll(f func(car *Car) bool) Cars {
	cars := make([]*Car, 0)
	cs.Proces(func(c *Car){
	    if f(c) {
		    cars = append(cars, a)	
        }   	
    })
	return cars
}
```

3）实现map功能，产出初car对象以外的东西：

```go
func (cs Cars) Map(f func(car *Car) Any) []Any {
	
	result := make([]Any, 0)
	ix := 0 
	cs.Proces(func(c *Car) {
	    result[ix] = f(c)
		ix ++
    })
	return result
}
```
现在我们可以定义下面的查询：

```go
allNewBMWs := allCars.FindAll(func(car *Car) bool {
	return (car.manu = 'bmw') && (car.buildyear>200)
})
```

4) 我们也可以根据入参返回不同的函数。也许我们想根据不同的厂商添加汽车到不同的集合，但这可能是多变的。
所以我们可以定义一个函数来产生特定的添加函数和map集：

```go
func MakeSortedAppender(manufacturers[]string)(func(car*Car),map[string]Cars) {
    // Prepare maps of sorted cars.
    sortedCars := make(map[string]Cars)
    for _, m := range manufacturers {
        sortedCars[m] = make([]*Car, 0)
    }
    sortedCars[“Default”] = make([]*Car, 0)
    // Prepare appender function:
    appender := func(c *Car) {
        if _, ok := sortedCars[c.Manufacturer]; ok {
            sortedCars[c.Manufacturer] = append(sortedCars[c.Manufacturer], c)
        } else {
            sortedCars[“Default”] = append(sortedCars[“Default”], c)
        }

    }
    return appender, sortedCars
}
```

现在我们可以用它把汽车分类作为独立的集合

```go
manufacturers := []string{“Ford”, “Aston Martin”, “Land Rover”, “BMW”, “Jaguar”}
sortedAppender, sortedCars := MakeSortedAppender(manufacturers)
allUnsortedCars.Process(sortedAppender)
BMWCount := len(sortedCars[“BMW”])
```




