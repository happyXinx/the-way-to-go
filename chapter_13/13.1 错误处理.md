
Go没有像java和.net那样的try-catch机制：不能执行异常操作。但是有一套
defer-panic-and-recover机制。

go是怎么处理普通错误呢？通过在函数和方法中返回错误对象作为它们的唯一或最后一个
返回值，如果返回nil,则没有错误发生，并且主调函数总是应该检查收到的错误。


**永远不要忽略错误，否则会导致程序崩溃。**

panic and recover是用来处理真正的异常（无法预知的错误）而不是普通的函数。
库函数通常必须返回某种错误提示给主调函数。

go中有一个预定义的error接口类型
```go
type error interface {
	Error() string
}
```

## 定义错误

当你需要一个新的错误类型，都可以使用error（必须先import）包的errors.New函数接收
合适的错误来创建。

```go
err := errors.New("math - square root of negative number")
```

在大部分情况下自定义错误类型很有意义，可以包含除了（低层级的）错误信息以外的
其他有用信息，例如，正在进行的操作（打开文件等），全路径或名字。

```go
// PathError records an error and the operation and file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error  // Returned by the system call.
}

func (e *PathError) String() string {
    return e.Op + " " + e.Path + ": "+ e.Err.Error()
}
```

如果有不同错误条件可能发生，那么对实际的错误使用类型断言或类型判断(type-switch)是很有用的，
并且可以根据错误场景做一些补救或恢复工作。

```go
if e, ok := err.(*os.PathError); ok {
	
}
```
或
```go
switch err := err.(type) {
    case ParseError:
		PrintParseError(err)
    case PathError:
		PrintPathError(err)
    ...
    default:
        fmt.Printf("Not a special error, just %s\n", err)	
}
```

## 使用fmt创建错误对象 

通常你想要返回包含错误参数的更有信息量的字符串，例如`fmt.Errorf()`来实现：
它和fmt.Printf()完全一样，接收有一个或多个格式占位符的格式化字符串和相应数量的
占位数量。

```go
if f < 0 {
	return 0, fmt.Errorf("math: %g", f)
}
```



