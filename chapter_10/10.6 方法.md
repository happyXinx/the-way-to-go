## 方法是什么

Go方法是作用在接收者上的一个函数，接收者是某种类型的变量。因此 方法是一种特殊类型的函数。

接收者类型可以是结构提类型、函数类型、int bool string或数组，但不能是接口类型，不能是指针类型。

一个类型加上它的方法等价于面向对象中的一个类。在Go中，类型的代码和绑定在它上面的方法
可以不放置在一起，但必须是同一个包的。

因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。
注意同样名字的方法可以在2个或多个不同的接收者类型上存在。


```go
func (a *denseMatrix) Add(b Matrix) Matrix
func (a *sparseMatrix) Add(b Matrix) Matrix
```

定义方法的一般格式如下：

```go
func (recv recevier_type) method(parameter_list) (return) {
	...
}
```

如果recv是reciver的实例， Method1是它的方法名，那么方法调用遵循传统的选择器符号：
recv.Method1()

如果recv是一个指针，Go会自动解引用。


## 函数和方法的区别

函数将变量作为参数： Function1(recv)
方法在变量上被调用： recv.Method1()


## 指针或值作为接收者

如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在
普通的值类型上定义方法。

指针方法和值方法都可以在指针或者非指针上被调用。比如对于类型T，如果×T存在方法Meth()，
并且t是这个类型的变量，那么t.Meth()会被自动转换为（&t).Meth()

## 方法和未导出字段


提供get和set方法

```go
package person

type Person struct {
    firstName string
    lastName  string
}

func (p *Person) FirstName() string {
    return p.firstName
}

func (p *Person) SetFirstName(newName string) {
    p.firstName = newName
}
```

## 内嵌类型的方法和继承

当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌。

```go
package main

import (
    "fmt"
    "math"
)

type Point struct {
    x, y float64
}

func (p *Point) Abs() float64 {
    return math.Sqrt(p.x*p.x + p.y*p.y)
}

type NamedPoint struct {
    Point
    name string
}

func main() {
    n := &NamedPoint{Point{3, 4}, "Pythagoras"}
    fmt.Println(n.Abs()) // 打印5
}
```

## 如何在类型中嵌入功能

A： 聚合： 包含一个所需功能的具名字段
B： 内嵌： 内嵌所需功能类型


## 多重继承

多重继承指的是类型获得多个父类型行为的能力

```go
package main

import (
    "fmt"
)

type Camera struct{}

func (c *Camera) TakeAPicture() string {
    return "Click"
}

type Phone struct{}

func (p *Phone) Call() string {
    return "Ring Ring"
}

type CameraPhone struct {
    Camera
    Phone
}

func main() {
    cp := new(CameraPhone)
    fmt.Println("Our new CameraPhone exhibits multiple behaviors...")
    fmt.Println("It exhibits behavior of a Camera: ", cp.TakeAPicture())
    fmt.Println("It works like a Phone too: ", cp.Call())
}

```




